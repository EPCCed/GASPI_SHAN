! ************************************************************************
!
!               miniGhost: stencil computations with boundary exchange.
!                 Copyright (2012) Sandia Corporation
!
! Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
! license for use of this work by or on behalf of the U.S. Government.
!
! This library is free software; you can redistribute it and/or modify
! it under the terms of the GNU Lesser General Public License as
! published by the Free Software Foundation; either version 2.1 of the
! License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful, but
! WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Lesser General Public License for more details.
!
! You should have received a copy of the GNU Lesser General Public
! License along with this library; if not, write to the Free Software
! Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
! USA
! Questions? Contact Richard F. Barrett (rfbarre@sandia.gov) or
!                    Michael A. Heroux (maherou@sandia.gov)
!
! ************************************************************************

MODULE DRIVER_SVAF_MOD

CONTAINS

   SUBROUTINE DRIVER_SVAF ( IERR )

   ! Purpose
   ! =======
   ! Driver for the single variable aggregated faces (SVAF)
   ! communication strategy. Called by the Fortran driver subroutine MINI_GHOST.

   USE MG_CONSTANTS_MOD
   USE MG_BUFINIT_MOD
   USE MG_SVAF_MOD
   USE MG_STENCIL_MOD
   USE MG_PROFILING_MOD
   USE MG_SUM_GRID_MOD

   IMPLICIT NONE

      INTEGER, INTENT(OUT) :: &
         IERR                        ! Return status

      ! ------------------
      ! Local Declarations
      ! ------------------
   
      INTEGER ::                  &
         IVAR,                    &  ! Counter (over variables)
         TYPE_ID,                 & 
         ISPIKE                      ! Counter (over NUM_SPIKES)
 
      REAL(KIND=MG_REAL) ::       &
         ERROR_ITER,              &  ! Difference between new and old GRIDi sum.
         GSUM                        ! Global SUM across GRIDs.

      REAL(KIND=MG_REAL8) ::      &
         TIME_START,              &
         TIME_START_2,            &
         TIME_START_ALL
   
      ! ---------------------
      ! Executable Statements
      ! ---------------------
   
      IERR = 0

      ! -------------------
      ! Begin time stepping
      ! -------------------

      TIME_START_ALL = MG_TIMER()

      DO ISPIKE = 1, NUM_SPIKES

         CALL MG_INSERT_SPIKE ( ISPIKE, IERR )

         DO TSTEP = 1, NUM_TSTEPS
            DO IVAR = 1, NUM_VARS
               TIME_START = MG_TIMER()
               IF ( STENCIL == STENCIL_2D5PT .OR. STENCIL == STENCIL_3D7PT ) THEN
                  CALL MG_SVAF ( IVAR, IERR )
                  CALL MG_ASSERT ( IERR, 'DRIVER_SVAF:MG_SVAF', IVAR )
               ELSE
                  IERR = -1
                  CALL MG_ASSERT ( IERR, 'DRIVER_SVAF: Unknown stencil for boundary exchange', STENCIL )
               END IF
               MG_PERF%TIME_SVAF_PE = MG_PERF%TIME_SVAF_PE + MG_TIMER() - TIME_START

               IF ( STENCIL /= STENCIL_NONE ) THEN
                  TIME_START = MG_TIMER()
                  CALL MG_STENCIL ( IVAR, IERR )
                  CALL MG_ASSERT ( IERR, 'DRIVER_SVAF:MG_STENCIL', IVAR )
                  MG_PERF%TIME_STENCIL_PE = MG_PERF%TIME_STENCIL_PE + MG_TIMER() - TIME_START
   
                  ! Reduction across GRID option
                  IF ( GRIDS_TO_SUM(IVAR) ) THEN
                     TIME_START_2 = MG_TIMER ()
                     CALL MG_SUM_GRID ( IVAR, GSUM, IERR )
                     CALL MG_ASSERT ( IERR, 'DRIVER_SVAF:MG_SUM_GRID', IVAR )
                     MG_PERF%TIME_SUMGRID_PE = MG_PERF%TIME_SUMGRID_PE + MG_TIMER () - TIME_START_2

                     IF ( MYPE == ROOT_PE ) THEN
                        ERROR_ITER = ABS ( SOURCE_TOTAL(IVAR) - GSUM ) / SOURCE_TOTAL(IVAR)
                        IF ( ERROR_ITER > ERROR_TOL ) THEN
                           WRITE(*,99) TSTEP, IVAR, ERROR_ITER, ERROR_TOL
                           IERR = -1
                           CALL MG_ASSERT ( IERR, 'DRIVER_SVAF', IVAR )
                        END IF
                        IF ( MOD ( TSTEP, REPORT_DIFFUSION ) == 0 ) THEN
                           WRITE(*,99) TSTEP, IVAR, ERROR_ITER, ERROR_TOL
                        END IF
                     END IF
                  END IF
               END IF
            END DO ! Variables
         END DO    ! Time step
      END DO       ! SPIKE insertion

      MG_PERF%TIME_WALL_PE = MG_TIMER() - TIME_START_ALL
   
      RETURN

 99   FORMAT ( 'Time step ', I4, ' for variable ', I4, ' the error is ', 1PE12.5 ' ; error tolerance is ', 1PE8.2, '.' )

   END SUBROUTINE DRIVER_SVAF

END MODULE DRIVER_SVAF_MOD
